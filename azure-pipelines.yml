# Azure DevOps Pipeline for CoPA Stop & Search
# Secure deployment with Infrastructure as Code using Bicep templates
# PASS: SOLUTION: Uses Azure PowerShell instead of Azure CLI to avoid the
# "content for this response was already consumed" bug in Azure CLI 2.77.0

trigger:
  branches:
    include:
    - main
    - Dev-Ops-Deployment
  paths:
    exclude:
    - '**/*.md'
    - 'docs/**'
    - '**/README*'
    - '.gitignore'
    - '.vscode/**'
    - '.devcontainer/**'
  batch: true  # Batch builds - if multiple commits come in quickly, batch them

pr:
  branches:
    include:
    - main
    - Dev-Ops-Deployment
  drafts: false

pool:
  vmImage: ubuntu-latest

# Global variables for the pipeline
variables:
  # Azure Resource Configuration
  azureServiceConnectionDev: 'BTP-Development'
  azureServiceConnectionProd: 'BTP-Production'
  azureLocation: 'uksouth'

  # Resource naming and configuration
  resourceGroupName: 'rg-btp-d-copa-stop-search'

  # OpenAI Configuration (overrideable via pipeline variables)
  openAIModel: 'gpt-35-turbo-16k'
  embeddingModel: 'text-embedding-ada-002'

  # Build and deployment settings
  pythonVersion: '3.10'
  nodeVersion: '18.x'
  vmImageName: 'ubuntu-latest'

  # Template and resource naming
  bicepTemplatePath: 'infra/main.bicep'
  bicepParametersPath: 'infra/main.parameters.json'
  webAppName: 'app-btp-d-copa-stop-search-001'

  # Performance optimizations
  AZURE_CORE_OUTPUT: 'table'
  AZURE_CORE_COLLECT_TELEMETRY: 'false'
  AZURE_CLI_DISABLE_CONNECTION_VERIFICATION: '1'

  # Build variables
  buildConfiguration: 'Release'

  # Skip stages based on commit message - saves time when fixing specific issues
  skipValidation: $[contains(variables['Build.SourceVersionMessage'], '[skip-validation]')]
  skipInfrastructure: $[contains(variables['Build.SourceVersionMessage'], '[skip-infrastructure]')]
  skipApplication: $[contains(variables['Build.SourceVersionMessage'], '[skip-app]')]

stages:
# ===================================================================================================
# STAGE 1: BUILD AND VALIDATION
# ===================================================================================================
- stage: BuildAndValidation
  displayName: 'Build, Test & Security Validation'
  condition: not(variables.skipBuild)
  jobs:
  - job: BuildValidation
    displayName: 'Build and Validation'
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: self
      fetchDepth: 1

# ===================================================================================================
# STAGE 2: FAST INFRASTRUCTURE VALIDATION
# ===================================================================================================
- stage: FastInfraValidation
  displayName: 'Fast Infrastructure Validation'
  condition: variables.infrastructureOnly
  jobs:
  - job: ValidateInfrastructureOnly
    displayName: 'Quick Bicep Validation'
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: self
      fetchDepth: 1  # Faster checkout

    - task: AzureCLI@2
      displayName: 'Quick Bicep Lint Check'
      inputs:
        azureSubscription: $(azureServiceConnectionDev)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Quick validation - installing Bicep..."
          az bicep install

          echo "Linting Bicep template..."
          az bicep lint --file $(bicepTemplatePath)

          echo "Building Bicep template..."
          az bicep build --file $(bicepTemplatePath)

          echo "Quick validation completed - proceeding to deployment"

- stage: Validate
  displayName: 'Validate Infrastructure and Code'
  condition: and(succeeded(), not(variables.skipValidation), not(variables.infrastructureOnly))
  jobs:
  - job: ValidateInfrastructure
    displayName: 'Validate Bicep Templates'
    pool:
      vmImage: $(vmImageName)
    steps:
    - checkout: self
      fetchDepth: 0

    - task: AzureCLI@2
      displayName: 'Install Bicep CLI'
      inputs:
        azureSubscription: $(azureServiceConnectionDev)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          az bicep install
          az bicep version

    - task: AzureCLI@2
      displayName: 'Validate Bicep Template'
      inputs:
        azureSubscription: $(azureServiceConnectionDev)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Validating Bicep template..."
          az bicep build --file $(bicepTemplatePath)

          echo "Linting Bicep template..."
          az bicep lint --file $(bicepTemplatePath)

    - task: AzureCLI@2
      displayName: 'Security Scan - What-If Analysis'
      inputs:
        azureSubscription: $(azureServiceConnectionDev)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Running what-if analysis at subscription level..."
          # Use subscription-level deployment for what-if analysis
          az deployment sub what-if \
            --location uksouth \
            --template-file $(bicepTemplatePath) \
            --parameters infra/main.devops.parameters.json \
            --verbose

          echo "What-if analysis completed successfully"

  - job: ValidateApplication
    displayName: 'Validate Application Code'
    pool:
      vmImage: $(vmImageName)
    steps:
    - checkout: self
      fetchDepth: 0

    - task: UsePythonVersion@0
      displayName: 'Set up Python $(pythonVersion)'
      inputs:
        versionSpec: '$(pythonVersion)'

    - task: NodeTool@0
      displayName: 'Set up Node.js $(nodeVersion)'
      inputs:
        versionSpec: '$(nodeVersion)'

    - script: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
        pip install flake8 black pylint safety bandit
      displayName: 'Install Python dependencies'

    - script: |
        cd frontend
        npm ci
      displayName: 'Install Node.js dependencies'

    - script: |
        echo "Running Python security scan with bandit..."
        bandit -r . -f json -o bandit-report.json --exclude ./frontend,./node_modules,./.venv || true

        echo "Running Python dependency security check..."
        safety check --json --output safety-report.json || true

        echo "Running Python linting for critical errors only..."
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics --exclude=frontend,node_modules,.venv

        echo "Running Python code formatting check (warnings only)..."
        black --check --diff . --exclude="/(frontend|node_modules|\.venv)/" || echo "Code formatting warnings detected but not failing build"
      displayName: 'Security and Quality Checks'

    - script: |
        cd frontend
        echo "Installing frontend dependencies..."
        npm ci

        echo "Running TypeScript type checking..."
        npm run typecheck

        echo "Building frontend application..."
        npm run build

        echo "Verifying build output..."
        if [ -f "../static/index.html" ] && [ -d "../static/assets" ]; then
          echo "Build successful - static directory and assets created"
          echo "Contents of ../static/:"
          ls -la ../static/
          echo "Contents of ../static/assets/:"
          ls -la ../static/assets/
        else
          echo "Build failed - no static directory or assets found"
          echo "Expected: ../static/index.html and ../static/assets/"
          echo "Checking what exists:"
          if [ -d "../static" ]; then
            echo "Static directory contents:"
            ls -la ../static/
          else
            echo "../static directory does not exist"
          fi
          exit 1
        fi
      displayName: 'Frontend Build and Lint'

    - task: PublishTestResults@2
      condition: always()
      inputs:
        testResultsFiles: '**/test-results.xml'
        mergeTestResults: true
      displayName: 'Publish Test Results'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Security Reports'
      condition: always()
      inputs:
        pathToPublish: '.'
        artifactName: 'security-reports'
        includes: |
          bandit-report.json
          safety-report.json

- stage: BuildAndPackage
  displayName: 'Build and Package Application'
  dependsOn: []
  condition: and(succeeded(), not(variables.skipBuild), not(variables.infrastructureOnly))
  jobs:
  - job: BuildApplication
    displayName: 'Build Application'
    pool:
      vmImage: $(vmImageName)
    steps:
    - checkout: self
      fetchDepth: 0

    - task: UsePythonVersion@0
      displayName: 'Set up Python $(pythonVersion)'
      inputs:
        versionSpec: '$(pythonVersion)'

    - task: NodeTool@0
      displayName: 'Set up Node.js $(nodeVersion)'
      inputs:
        versionSpec: '$(nodeVersion)'

    - script: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
      displayName: 'Install Python dependencies'

    - script: |
        cd frontend
        echo "Installing frontend dependencies..."
        npm ci

        echo "Building frontend application..."
        npm run build

        echo "Verifying build output..."
        if [ -f "../static/index.html" ] && [ -d "../static/assets" ]; then
          echo "Frontend build successful"
          echo "Contents of ../static/:"
          ls -la ../static/
          echo "Contents of ../static/assets/:"
          ls -la ../static/assets/
        else
          echo "Frontend build failed - no static directory or assets found"
          echo "Expected: ../static/index.html and ../static/assets/"
          echo "Checking what exists:"
          if [ -d "../static" ]; then
            echo "Static directory contents:"
            ls -la ../static/
          else
            echo "../static directory does not exist"
          fi
          exit 1
        fi
      displayName: 'Build Frontend'

    - script: |
        echo "Preparing deployment package..."
        mkdir -p $(Build.ArtifactStagingDirectory)/app

        # Copy application files
        cp -r *.py $(Build.ArtifactStagingDirectory)/app/ || true
        cp -r backend/ $(Build.ArtifactStagingDirectory)/app/ || true
        cp -r static/ $(Build.ArtifactStagingDirectory)/app/ || true
        cp requirements.txt $(Build.ArtifactStagingDirectory)/app/
        cp start.sh $(Build.ArtifactStagingDirectory)/app/
        cp gunicorn.conf.py $(Build.ArtifactStagingDirectory)/app/ || true
        cp WebApp.Dockerfile $(Build.ArtifactStagingDirectory)/app/ || true

        # Static directory (including built frontend) is already copied above
        echo "Frontend build files included in static/ directory"

        echo "Application package prepared"
        ls -la $(Build.ArtifactStagingDirectory)/app/
      displayName: 'Package Application'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Application Artifact'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)/app'
        artifactName: 'copa-application'

  - job: PackageInfrastructure
    displayName: 'Package Infrastructure'
    pool:
      vmImage: $(vmImageName)
    steps:
    - checkout: self
      fetchDepth: 0

    - script: |
        echo "Preparing infrastructure package..."
        mkdir -p $(Build.ArtifactStagingDirectory)/infra

        # Copy Bicep templates
        cp -r infra/ $(Build.ArtifactStagingDirectory)/

        # Copy createUIDefinition for portal deployments (backup option)
        cp infrastructure/createUiDefinition.json $(Build.ArtifactStagingDirectory)/infra/ || true

        echo "Infrastructure package prepared"
        ls -la $(Build.ArtifactStagingDirectory)/infra/
      displayName: 'Package Infrastructure'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Infrastructure Artifact'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)/infra'
        artifactName: 'copa-infrastructure'

- stage: DeployDevelopment
  displayName: 'Deploy to Development'
  dependsOn: 
  - BuildAndPackage
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/Dev-Ops-Deployment'))
  variables:
  - group: 'copa-stop-search-dev-variables'
  - name: environmentName
    value: 'development'
  - name: resourceGroupName
    value: 'rg-btp-d-copa-stop-search'
  - name: azureLocation
    value: 'uksouth'
  - name: openAIModel
    value: 'gpt-35-turbo-16k'
  - name: embeddingModel
    value: 'text-embedding-ada-002'
  jobs:
  - deployment: DeployInfrastructure
    displayName: 'Deploy Infrastructure to Development'
    environment: 'BTP-Development'
    pool:
      vmImage: $(vmImageName)
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
            fetchDepth: 1
            condition: variables.infrastructureOnly

          - task: DownloadBuildArtifacts@1
            displayName: 'Download Infrastructure Artifacts'
            condition: and(succeeded(), not(variables.infrastructureOnly), not(variables.skipBuild))
            inputs:
              buildType: 'current'
              artifactName: 'copa-infrastructure'
              downloadPath: '$(Pipeline.Workspace)'

          - task: DownloadBuildArtifacts@1
            displayName: 'Download Application Artifacts'
            condition: and(succeeded(), not(variables.infrastructureOnly), not(variables.skipBuild))
            inputs:
              buildType: 'current'
              artifactName: 'copa-application'
              downloadPath: '$(Pipeline.Workspace)'

          - task: AzureCLI@2
            displayName: 'Create Resource Group'
            inputs:
              azureSubscription: $(azureServiceConnectionDev)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Creating resource group with required BTP policy tags..."
                az group create \
                  --name $(resourceGroupName) \
                  --location $(azureLocation) \
                  --tags \
                    Owner="DevOps-Pipeline" \
                    CostCentre="IT-001" \
                    ForceID="BTP" \
                    ServiceName="CoPA-Stop-Search" \
                    LocationID="UK-South" \
                    Environment="Development"
                echo "Resource group created successfully with all required tags"

          - task: AzurePowerShell@5
            displayName: 'Deploy Infrastructure with PowerShell (Avoiding CLI Bug)'
            inputs:
              azureSubscription: $(azureServiceConnectionDev)
              ScriptType: 'InlineScript'
              azurePowerShellVersion: 'LatestVersion'
              pwsh: true
              Inline: |
                $ErrorActionPreference = 'Stop'

                Write-Host "START: Starting PowerShell-based infrastructure deployment (Bypassing Azure CLI 2.77.0 bug)"

                # Always use source files when artifacts aren't downloaded
                $artifactsPath = "$(Pipeline.Workspace)/copa-infrastructure/main.bicep"
                $sourcePath = "infra/main.bicep"

                if (Test-Path $artifactsPath) {
                  Write-Host "PACKAGE: Using pipeline artifacts (full deployment mode)"
                  $templatePath = $artifactsPath
                  $parametersPath = "$(Pipeline.Workspace)/copa-infrastructure/main.devops.parameters.json"
                } else {
                  Write-Host "FOLDER: Using source files (infrastructure-only mode or no artifacts)"
                  $templatePath = $sourcePath
                  $parametersPath = "infra/main.devops.parameters.json"
                }

                Write-Host "FILE: Template path: $templatePath"
                Write-Host "CONFIG:  Parameters path: $parametersPath"

                # Verify files exist
                if (-not (Test-Path $templatePath)) {
                  Write-Error "FAIL: Template file not found at: $templatePath"
                  Write-Host "  Current directory: $(Get-Location)"
                  if (Test-Path "infra/") {
                    Write-Host "INFO: Available files in infra/:"
                    Get-ChildItem "infra/" | Format-Table Name, Length
                  }
                  throw "Template file not found"
                }

                if (-not (Test-Path $parametersPath)) {
                  Write-Error "FAIL: Parameters file not found at: $parametersPath"
                  throw "Parameters file not found"
                }

                Write-Host "PASS: Files verified successfully"

                # Load parameters from JSON file
                try {
                  $parametersJson = Get-Content -Path $parametersPath -Raw | ConvertFrom-Json
                  $parameters = @{}

                  # Convert JSON parameters to hashtable format required by PowerShell
                  $parametersJson.parameters.PSObject.Properties | ForEach-Object {
                    $parameters[$_.Name] = $_.Value.value
                  }

                  Write-Host "INFO: Loaded parameters from file:"
                  $parameters.GetEnumerator() | Sort-Object Name | ForEach-Object {
                    if ($_.Name -like "*password*" -or $_.Name -like "*key*" -or $_.Name -like "*secret*") {
                      Write-Host "  $($_.Name) = ***MASKED***"
                    } else {
                      Write-Host "  $($_.Name) = $($_.Value)"
                    }
                  }

                  # Add OpenAI model parameters if variables are set
                  if ("$(openAIModel)" -ne "`$(openAIModel)" -and "$(openAIModel)" -ne "") {
                    $parameters['openAIModelName'] = "$(openAIModel)"
                    Write-Host "AI: Added OpenAI model: $(openAIModel)"
                  }

                  if ("$(embeddingModel)" -ne "`$(embeddingModel)" -and "$(embeddingModel)" -ne "") {
                    $parameters['embeddingModelName'] = "$(embeddingModel)"
                    Write-Host "DATA: Added embedding model: $(embeddingModel)"
                  }

                } catch {
                  Write-Error "FAIL: Failed to load parameters: $($_.Exception.Message)"
                  throw
                }

                # Create deployment name
                $deploymentName = "$(Build.BuildNumber)-infrastructure-$((Get-Date).ToString('yyyyMMdd-HHmmss'))"
                Write-Host "TAG:  Deployment name: $deploymentName"

                try {
                  # First, validate the template before attempting deployment
                  Write-Host "VALIDATE: Validating Bicep template before deployment..."
                  Write-Host "LOCATION: Target location: $(azureLocation)"

                  $validationResult = Test-AzSubscriptionDeployment `
                    -Location "$(azureLocation)" `
                    -TemplateFile $templatePath `
                    -TemplateParameterObject $parameters `
                    -Verbose

                  if ($validationResult) {
                    Write-Host "FAIL: Template validation failed with the following errors:"
                    foreach ($error in $validationResult) {
                      Write-Host "  ERROR: Error Code: $($error.Code)"
                      Write-Host "  MESSAGE: Message: $($error.Message)"
                      if ($error.Details) {
                        Write-Host "    Details: $($error.Details | ConvertTo-Json -Depth 3)"
                      }
                      if ($error.Target) {
                        Write-Host "  TARGET: Target: $($error.Target)"
                      }
                    }
                    throw "Template validation failed. See errors above."
                  }

                  Write-Host "PASS: Template validation passed successfully!"

                  # Deploy infrastructure using PowerShell (avoids CLI response handling bug)
                  Write-Host "START: Starting Bicep deployment with PowerShell..."

                  $deploymentResult = New-AzSubscriptionDeployment `
                    -Name $deploymentName `
                    -Location "$(azureLocation)" `
                    -TemplateFile $templatePath `
                    -TemplateParameterObject $parameters `
                    -Verbose

                  Write-Host "PASS: Infrastructure deployment completed successfully!"
                  Write-Host "DATA: Final State: $($deploymentResult.ProvisioningState)"
                  Write-Host "  Deployment ID: $($deploymentResult.Id)"

                  # Output deployment results
                  if ($deploymentResult.Outputs) {
                    Write-Host "  Deployment Outputs:"
                    $deploymentResult.Outputs | ConvertTo-Json -Depth 3

                    # Extract web app name from outputs or use BTP naming convention
                    if ($deploymentResult.Outputs.ContainsKey('webAppName')) {
                      $webAppName = $deploymentResult.Outputs.webAppName.Value
                    } elseif ($deploymentResult.Outputs.ContainsKey('appServiceName')) {
                      $webAppName = $deploymentResult.Outputs.appServiceName.Value
                    } else {
                      $webAppName = "$(webAppName)"
                    }
                  } else {
                    # Fallback to pipeline variable or BTP naming convention
                    $webAppName = "$(webAppName)"
                  }

                  Write-Host "WEB: Web App Name: $webAppName"
                  Write-Host "##vso[task.setvariable variable=webAppName;isOutput=true]$webAppName"

                } catch {
                  Write-Error "FAIL: PowerShell deployment failed: $($_.Exception.Message)"
                  Write-Host "VALIDATE: Exception details: $($_.Exception.ToString())"

                  # Try to get deployment details for debugging
                  try {
                    Write-Host "VALIDATE: Attempting to get deployment status..."
                    $deployment = Get-AzSubscriptionDeployment -Name $deploymentName -ErrorAction SilentlyContinue
                    if ($deployment) {
                      Write-Host "DATA: Deployment State: $($deployment.ProvisioningState)"

                      if ($deployment.ProvisioningState -eq "Failed") {
                        Write-Host "VALIDATE: Getting deployment operation details..."
                        $operations = Get-AzSubscriptionDeploymentOperation -DeploymentName $deploymentName -ErrorAction SilentlyContinue

                        if ($operations) {
                          foreach ($op in $operations | Where-Object { $_.Properties.ProvisioningState -eq "Failed" }) {
                            Write-Host "FAIL: Failed Operation:"
                            Write-Host "  Resource: $($op.Properties.TargetResource.ResourceName)"
                            Write-Host "  Type: $($op.Properties.TargetResource.ResourceType)"
                            if ($op.Properties.StatusMessage) {
                              Write-Host "  Error: $($op.Properties.StatusMessage | ConvertTo-Json -Depth 5)"
                            }
                          }
                        }
                      }
                    } else {
                      Write-Host "   Could not retrieve deployment information"
                    }
                  } catch {
                    Write-Host "   Error getting deployment details: $($_.Exception.Message)"
                  }

                  throw
                }

          - task: AzureCLI@2
            displayName: 'Verify Web App Exists'
            condition: not(variables.infrastructureOnly)
            inputs:
              azureSubscription: $(azureServiceConnectionDev)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Use the pipeline variable for web app name
                WEBAPP_NAME="$(webAppName)"
                echo "Checking if web app exists: $WEBAPP_NAME"

                if az webapp show --name "$WEBAPP_NAME" --resource-group "$(resourceGroupName)" >/dev/null 2>&1; then
                  echo "PASS: Web app $WEBAPP_NAME exists and is ready for deployment"
                else
                  echo "FAIL: Web app $WEBAPP_NAME does not exist!"
                  echo "Available web apps in resource group $(resourceGroupName):"
                  az webapp list --resource-group "$(resourceGroupName)" --query "[].name" --output table || echo "No web apps found"
                  
                  # Also check if resource group exists
                  echo "Checking if resource group exists..."
                  if az group show --name "$(resourceGroupName)" >/dev/null 2>&1; then
                    echo "Resource group $(resourceGroupName) exists"
                  else
                    echo "ERROR: Resource group $(resourceGroupName) does not exist!"
                    echo "This indicates the infrastructure deployment may have failed"
                  fi
                  
                  exit 1
                fi

          - task: AzureWebApp@1
            displayName: 'Deploy Application'
            condition: and(succeeded(), not(variables.infrastructureOnly), not(variables.skipBuild))
            inputs:
              azureSubscription: $(azureServiceConnectionDev)
              appType: 'webAppLinux'
              appName: '$(webAppName)'
              package: '$(Pipeline.Workspace)/copa-application'
              runtimeStack: 'PYTHON|3.11'

          - task: AzureCLI@2
            displayName: 'Verify Application Deployment'
            condition: and(succeeded(), not(variables.infrastructureOnly), not(variables.skipBuild))
            inputs:
              azureSubscription: $(azureServiceConnectionDev)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Verifying web app deployment..."
                WEBAPP_NAME="$(webAppName)"
                WEB_APP_URL="https://$WEBAPP_NAME.azurewebsites.net"
                echo "Web app URL: $WEB_APP_URL"

                # Wait a moment for the app to start
                sleep 30

                # Check if the app is responding
                HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$WEB_APP_URL" || echo "000")
                echo "HTTP Status: $HTTP_STATUS"

                if [[ "$HTTP_STATUS" == "200" ]] || [[ "$HTTP_STATUS" == "302" ]]; then
                  echo "PASS: Web app is responding successfully"
                else
                  echo "  Web app returned status $HTTP_STATUS, but deployment completed"
                  echo "This might be normal if the app takes time to start"
                fi

- stage: DeployProduction
  displayName: 'Deploy to Production'
  dependsOn: BuildAndPackage
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  variables:
  - group: 'copa-stop-search-prod-variables'
  - name: environmentName
    value: 'production'
  - name: resourceGroupName
    value: 'rg-btp-p-copa-stop-search'
  - name: azureLocation
    value: 'uksouth'
  - name: openAIModel
    value: 'gpt-35-turbo-16k'
  - name: embeddingModel
    value: 'text-embedding-ada-002'
  jobs:
  - deployment: DeployInfrastructure
    displayName: 'Deploy Infrastructure to Production'
    environment: 'BTP-Production'
    pool:
      vmImage: $(vmImageName)
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: none

          - task: DownloadBuildArtifacts@1
            displayName: 'Download Infrastructure Artifacts'
            condition: and(succeeded(), not(variables.infrastructureOnly), not(variables.skipBuild))
            inputs:
              buildType: 'current'
              artifactName: 'copa-infrastructure'
              downloadPath: '$(Pipeline.Workspace)'

          - task: DownloadBuildArtifacts@1
            displayName: 'Download Application Artifacts'
            condition: and(succeeded(), not(variables.infrastructureOnly), not(variables.skipBuild))
            inputs:
              buildType: 'current'
              artifactName: 'copa-application'
              downloadPath: '$(Pipeline.Workspace)'

          - task: AzureCLI@2
            displayName: 'Create Resource Group'
            inputs:
              azureSubscription: $(azureServiceConnectionProd)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Creating production resource group with required BTP policy tags..."
                az group create \
                  --name $(resourceGroupName) \
                  --location $(azureLocation) \
                  --tags \
                    Owner="Production-Team" \
                    CostCentre="IT-001" \
                    ForceID="BTP" \
                    ServiceName="CoPA-Stop-Search" \
                    LocationID="UK-South" \
                    Environment="Production"
                echo "Production resource group created successfully with all required tags"

          - task: AzurePowerShell@5
            displayName: 'Deploy Infrastructure with PowerShell (Production)'
            inputs:
              azureSubscription: $(azureServiceConnectionProd)
              ScriptType: 'InlineScript'
              azurePowerShellVersion: 'LatestVersion'
              pwsh: true
              Inline: |
                $ErrorActionPreference = 'Stop'

                Write-Host "START: Starting PRODUCTION PowerShell-based infrastructure deployment"

                # Fallback logic for production deployment
                $artifactsTemplatePath = "$(Pipeline.Workspace)/copa-infrastructure/main.bicep"
                $sourceTemplatePath = "infra/main.bicep"
                
                if (Test-Path $artifactsTemplatePath) {
                  Write-Host "PACKAGE: Using pipeline artifacts for production deployment"
                  $templatePath = $artifactsTemplatePath
                  $parametersPath = "$(Pipeline.Workspace)/copa-infrastructure/main.production.parameters.json"
                } else {
                  Write-Host "FOLDER: Using source files for production deployment (infrastructure-only mode)"
                  $templatePath = $sourceTemplatePath
                  $parametersPath = "infra/main.production.parameters.json"
                }

                Write-Host "FILE: Production Template path: $templatePath"
                Write-Host "CONFIG: Production Parameters path: $parametersPath"

                # Verify files exist
                if (-not (Test-Path $templatePath)) {
                  Write-Error "FAIL: Production template file not found at: $templatePath"
                  if (Test-Path "$(Pipeline.Workspace)/copa-infrastructure/") {
                    Write-Host "  Available files in artifact:"
                    Get-ChildItem "$(Pipeline.Workspace)/copa-infrastructure/" | Format-Table Name, Length
                  } else {
                    Write-Host "  Artifact directory not found - using source files"
                  }
                  throw "Production template file not found"
                }

                if (-not (Test-Path $parametersPath)) {
                  Write-Error "FAIL: Production parameters file not found at: $parametersPath"
                  throw "Production parameters file not found"
                }

                Write-Host "PASS: Production files verified successfully"

                # Load parameters for production
                try {
                  $parametersJson = Get-Content -Path $parametersPath -Raw | ConvertFrom-Json
                  $parameters = @{}

                  # Convert JSON parameters to hashtable
                  $parametersJson.parameters.PSObject.Properties | ForEach-Object {
                    $parameters[$_.Name] = $_.Value.value
                  }

                  Write-Host "INFO: Loaded PRODUCTION parameters:"
                  $parameters.GetEnumerator() | Sort-Object Name | ForEach-Object {
                    if ($_.Name -like "*password*" -or $_.Name -like "*key*" -or $_.Name -like "*secret*") {
                      Write-Host "  $($_.Name) = ***MASKED***"
                    } else {
                      Write-Host "  $($_.Name) = $($_.Value)"
                    }
                  }

                  # Add OpenAI model parameters for production
                  if ("$(openAIModel)" -ne "`$(openAIModel)" -and "$(openAIModel)" -ne "") {
                    $parameters['openAIModelName'] = "$(openAIModel)"
                    Write-Host "AI: Added PRODUCTION OpenAI model: $(openAIModel)"
                  }

                  if ("$(embeddingModel)" -ne "`$(embeddingModel)" -and "$(embeddingModel)" -ne "") {
                    $parameters['embeddingModelName'] = "$(embeddingModel)"
                    Write-Host "DATA: Added PRODUCTION embedding model: $(embeddingModel)"
                  }

                } catch {
                  Write-Error "FAIL: Failed to load production parameters: $($_.Exception.Message)"
                  throw
                }

                # Create production deployment name
                $deploymentName = "$(Build.BuildNumber)-prod-infrastructure-$((Get-Date).ToString('yyyyMMdd-HHmmss'))"
                Write-Host "TAG:  PRODUCTION Deployment name: $deploymentName"

                try {
                  # First, validate the production template before attempting deployment
                  Write-Host "  Validating PRODUCTION Bicep template before deployment..."
                  Write-Host "LOCATION: Target location: $(azureLocation)"

                  $validationResult = Test-AzSubscriptionDeployment `
                    -Location "$(azureLocation)" `
                    -TemplateFile $templatePath `
                    -TemplateParameterObject $parameters `
                    -Verbose

                  if ($validationResult) {
                    Write-Host "FAIL: PRODUCTION template validation failed with the following errors:"
                    foreach ($validationError in $validationResult) {
                      Write-Host "  ERROR: Error Code: $($validationError.Code)"
                      Write-Host "  MESSAGE: Message: $($validationError.Message)"
                      if ($validationError.Details) {
                        Write-Host "  VALIDATE: Details: $($validationError.Details | ConvertTo-Json -Depth 3)"
                      }
                      if ($validationError.Target) {
                        Write-Host "  TARGET: Target: $($validationError.Target)"
                      }
                    }
                    throw "PRODUCTION template validation failed. See errors above."
                  }

                  Write-Host "PASS: PRODUCTION template validation passed successfully!"

                  # Deploy production infrastructure using PowerShell
                  Write-Host "START: Starting PRODUCTION Bicep deployment with PowerShell..."

                  $deploymentResult = New-AzSubscriptionDeployment `
                    -Name $deploymentName `
                    -Location "$(azureLocation)" `
                    -TemplateFile $templatePath `
                    -TemplateParameterObject $parameters `
                    -Verbose

                  Write-Host "PASS: PRODUCTION infrastructure deployment completed successfully!"
                  Write-Host "DATA: Final State: $($deploymentResult.ProvisioningState)"
                  Write-Host "  Deployment ID: $($deploymentResult.Id)"

                  # Output deployment results for production
                  if ($deploymentResult.Outputs) {
                    Write-Host "  PRODUCTION Deployment Outputs:"
                    $deploymentResult.Outputs | ConvertTo-Json -Depth 3

                    # Extract web app name for production
                    if ($deploymentResult.Outputs.ContainsKey('webAppName')) {
                      $webAppName = $deploymentResult.Outputs.webAppName.Value
                    } elseif ($deploymentResult.Outputs.ContainsKey('appServiceName')) {
                      $webAppName = $deploymentResult.Outputs.appServiceName.Value
                    } else {
                      $webAppName = "app-btp-p-copa-stop-search-001"
                    }
                  } else {
                    # Fallback to production BTP naming convention
                    $webAppName = "app-btp-p-copa-stop-search-001"
                  }

                  Write-Host "WEB: PRODUCTION Web App Name: $webAppName"
                  Write-Host "##vso[task.setvariable variable=webAppName;isOutput=true]$webAppName"

                } catch {
                  Write-Error "FAIL: PRODUCTION PowerShell deployment failed: $($_.Exception.Message)"
                  Write-Host "VALIDATE: Exception details: $($_.Exception.ToString())"

                  # Try to get production deployment details for debugging
                  try {
                    Write-Host "VALIDATE: Getting PRODUCTION deployment status..."
                    $deployment = Get-AzSubscriptionDeployment -Name $deploymentName -ErrorAction SilentlyContinue
                    if ($deployment) {
                      Write-Host "DATA: PRODUCTION Deployment State: $($deployment.ProvisioningState)"

                      if ($deployment.ProvisioningState -eq "Failed") {
                        Write-Host "VALIDATE: Getting PRODUCTION deployment operation details..."
                        $operations = Get-AzSubscriptionDeploymentOperation -DeploymentName $deploymentName -ErrorAction SilentlyContinue

                        if ($operations) {
                          foreach ($op in $operations | Where-Object { $_.Properties.ProvisioningState -eq "Failed" }) {
                            Write-Host "FAIL: Failed PRODUCTION Operation:"
                            Write-Host "  Resource: $($op.Properties.TargetResource.ResourceName)"
                            Write-Host "  Type: $($op.Properties.TargetResource.ResourceType)"
                            if ($op.Properties.StatusMessage) {
                              Write-Host "  Error: $($op.Properties.StatusMessage | ConvertTo-Json -Depth 5)"
                            }
                          }
                        }
                      }
                    }
                  } catch {
                    Write-Host "   Error getting PRODUCTION deployment details: $($_.Exception.Message)"
                  }

                  throw
                }

          - task: AzureCLI@2
            displayName: 'Verify Web App Exists'
            inputs:
              azureSubscription: $(azureServiceConnectionProd)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Use the pipeline variable for production web app name
                WEBAPP_NAME="$(webAppName)"
                echo "Checking if production web app exists: $WEBAPP_NAME"

                if az webapp show --name "$WEBAPP_NAME" --resource-group "$(resourceGroupName)" >/dev/null 2>&1; then
                  echo "PASS: Production web app $WEBAPP_NAME exists and is ready for deployment"
                else
                  echo "FAIL: Production web app $WEBAPP_NAME does not exist!"
                  echo "Available web apps in resource group $(resourceGroupName):"
                  az webapp list --resource-group "$(resourceGroupName)" --query "[].name" --output table || echo "No web apps found"
                  exit 1
                fi

          - task: AzureWebApp@1
            displayName: 'Deploy Application'
            inputs:
              azureSubscription: $(azureServiceConnectionProd)
              appType: 'webAppLinux'
              appName: '$(webAppName)'
              package: '$(Pipeline.Workspace)/copa-application'
              runtimeStack: 'PYTHON|3.11'

          - task: AzureCLI@2
            displayName: 'Verify Production Application Deployment'
            inputs:
              azureSubscription: $(azureServiceConnectionProd)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Verifying production web app deployment..."
                WEBAPP_NAME="$(webAppName)"
                WEB_APP_URL="https://$WEBAPP_NAME.azurewebsites.net"
                echo "Production web app URL: $WEB_APP_URL"

                # Wait a moment for the app to start
                sleep 30

                # Check if the app is responding
                HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$WEB_APP_URL" || echo "000")
                echo "HTTP Status: $HTTP_STATUS"

                if [[ "$HTTP_STATUS" == "200" ]] || [[ "$HTTP_STATUS" == "302" ]]; then
                  echo "PASS: Production web app is responding successfully"
                else
                  echo "  Production web app returned status $HTTP_STATUS, but deployment completed"
                  echo "This might be normal if the app takes time to start"
                fi