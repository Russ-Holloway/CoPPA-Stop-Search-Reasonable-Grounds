# Azure DevOps Pipeline for CoPA Stop & Search
# Secure deployment with Infrastructure as Code using Bicep templates
# ‚úÖ SOLUTION: Uses Azure PowerShell instead of Azure CLI to avoid the
# "content for this response was already consumed" bug in Azure CLI 2.77.0

trigger:
  branches:
    include:
    - main
    - Dev-Ops-Deployment
  paths:
    exclude:
    - '**/*.md'
    - 'docs/**'
    - '**/README*'
    - '.gitignore'
    - '.vscode/**'
    - '.devcontainer/**'
  batch: true  # Batch builds - if mult                  if ($validationResult) {
                    Write-Host "‚ùå Template validation failed with the following errors:"
                    foreach ($validationError in $validationResult) {
                      Write-Host "  üö´ Error Code: $($validationError.Code)"
                      Write-Host "  üìù Message: $($validationError.Message)"
                      if ($validationError.Details) {
                        Write-Host "  üîç Details: $($validationError.Details | ConvertTo-Json -Depth 3)"
                      }
                      if ($validationError.Target) {
                        Write-Host "  üéØ Target: $($validationError.Target)"
                      }
                    }
                    throw "Template validation failed. See errors above."
                  }ushed quickly, only build the latest

pr: none  # Disable automatic PR builds - manual trigger only for PRs

# Pool configuration for optimal performance
pool:
  vmImage: 'ubuntu-latest'
  demands:
  - azureps  # Requires Azure PowerShell capability

# Variables to control which stages run - set these in your commit message
variables:
  # Global variables
  - name: azureServiceConnectionDev
    value: 'BTP-Development'
  - name: azureServiceConnectionProd
    value: 'BTP-Production'
  - name: vmImageName
    value: 'ubuntu-latest'
  - name: bicepTemplatePath
    value: 'infra/main.bicep'
  
  # Performance optimizations
  - name: AZURE_CORE_OUTPUT
    value: 'table'
  - name: AZURE_CORE_COLLECT_TELEMETRY
    value: 'false'
  - name: AZURE_CLI_DISABLE_CONNECTION_VERIFICATION
    value: '1'
  - name: bicepParametersPath
    value: 'infra/main.parameters.json'
  
  # Build variables
  - name: buildConfiguration
    value: 'Release'
  - name: pythonVersion
    value: '3.11'
  - name: nodeVersion
    value: '18'
  
  # Skip stages based on commit message - saves time when fixing specific issues
  - name: skipValidation
    value: $[contains(variables['Build.SourceVersionMessage'], '[skip-validation]')]
  - name: skipBuild  
    value: $[contains(variables['Build.SourceVersionMessage'], '[skip-build]')]
  - name: infrastructureOnly
    value: $[contains(variables['Build.SourceVersionMessage'], '[infra-only]')]

stages:
- stage: FastInfraValidation
  displayName: 'Fast Infrastructure Validation'
  condition: variables.infrastructureOnly
  jobs:
  - job: ValidateInfrastructureOnly
    displayName: 'Quick Bicep Validation'
    pool:
      vmImage: $(vmImageName)
    steps:
    - checkout: self
      fetchDepth: 1  # Faster checkout
      
    - task: AzureCLI@2
      displayName: 'Quick Bicep Lint Check'
      inputs:
        azureSubscription: $(azureServiceConnectionDev)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Quick validation - installing Bicep..."
          az bicep install
          
          echo "Linting Bicep template..."
          az bicep lint --file $(bicepTemplatePath)
          
          echo "Building Bicep template..."
          az bicep build --file $(bicepTemplatePath)
          
          echo "Quick validation completed - proceeding to deployment"

- stage: Validate
  displayName: 'Validate Infrastructure and Code'
  condition: and(succeeded(), not(variables.skipValidation), not(variables.infrastructureOnly))
  jobs:
  - job: ValidateInfrastructure
    displayName: 'Validate Bicep Templates'
    pool:
      vmImage: $(vmImageName)
    steps:
    - checkout: self
      fetchDepth: 0
      
    - task: AzureCLI@2
      displayName: 'Install Bicep CLI'
      inputs:
        azureSubscription: $(azureServiceConnectionDev)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          az bicep install
          az bicep version
    
    - task: AzureCLI@2
      displayName: 'Validate Bicep Template'
      inputs:
        azureSubscription: $(azureServiceConnectionDev)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Validating Bicep template..."
          az bicep build --file $(bicepTemplatePath)
          
          echo "Linting Bicep template..."
          az bicep lint --file $(bicepTemplatePath)
    
    - task: AzureCLI@2
      displayName: 'Security Scan - What-If Analysis'
      inputs:
        azureSubscription: $(azureServiceConnectionDev)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Running what-if analysis at subscription level..."
          # Use subscription-level deployment for what-if analysis
          az deployment sub what-if \
            --location uksouth \
            --template-file $(bicepTemplatePath) \
            --parameters infra/main.devops.parameters.json \
            --verbose
          
          echo "What-if analysis completed successfully"
        
  - job: ValidateApplication
    displayName: 'Validate Application Code'
    pool:
      vmImage: $(vmImageName)
    steps:
    - checkout: self
      fetchDepth: 0
      
    - task: UsePythonVersion@0
      displayName: 'Set up Python $(pythonVersion)'
      inputs:
        versionSpec: '$(pythonVersion)'
        
    - task: NodeTool@0
      displayName: 'Set up Node.js $(nodeVersion)'
      inputs:
        versionSpec: '$(nodeVersion)'
        
    - script: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
        pip install flake8 black pylint safety bandit
      displayName: 'Install Python dependencies'
      
    - script: |
        cd frontend
        npm ci
      displayName: 'Install Node.js dependencies'
      
    - script: |
        echo "Running Python security scan with bandit..."
        bandit -r . -f json -o bandit-report.json --exclude ./frontend,./node_modules,./.venv || true
        
        echo "Running Python dependency security check..."
        safety check --json --output safety-report.json || true
        
        echo "Running Python linting for critical errors only..."
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics --exclude=frontend,node_modules,.venv
        
        echo "Running Python code formatting check (warnings only)..."
        black --check --diff . --exclude="/(frontend|node_modules|\.venv)/" || echo "Code formatting warnings detected but not failing build"
      displayName: 'Security and Quality Checks'
      
    - script: |
        cd frontend
        echo "Installing frontend dependencies..."
        npm ci
        
        echo "Running TypeScript type checking..."
        npm run typecheck
        
        echo "Building frontend application..."
        npm run build
        
        echo "Verifying build output..."
        if [ -f "../static/index.html" ] && [ -d "../static/assets" ]; then
          echo "Build successful - static directory and assets created"
          echo "Contents of ../static/:"
          ls -la ../static/
          echo "Contents of ../static/assets/:"
          ls -la ../static/assets/
        else
          echo "Build failed - no static directory or assets found"
          echo "Expected: ../static/index.html and ../static/assets/"
          echo "Checking what exists:"
          if [ -d "../static" ]; then
            echo "Static directory contents:"
            ls -la ../static/
          else
            echo "../static directory does not exist"
          fi
          exit 1
        fi
      displayName: 'Frontend Build and Lint'
      
    - task: PublishTestResults@2
      condition: always()
      inputs:
        testResultsFiles: '**/test-results.xml'
        mergeTestResults: true
      displayName: 'Publish Test Results'
      
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Security Reports'
      condition: always()
      inputs:
        pathToPublish: '.'
        artifactName: 'security-reports'
        includes: |
          bandit-report.json
          safety-report.json

- stage: BuildAndPackage
  displayName: 'Build and Package Application'
  dependsOn: []
  condition: and(succeeded(), not(variables.skipBuild), not(variables.infrastructureOnly))
  jobs:
  - job: BuildApplication
    displayName: 'Build Application'
    pool:
      vmImage: $(vmImageName)
    steps:
    - checkout: self
      fetchDepth: 0
      
    - task: UsePythonVersion@0
      displayName: 'Set up Python $(pythonVersion)'
      inputs:
        versionSpec: '$(pythonVersion)'
        
    - task: NodeTool@0
      displayName: 'Set up Node.js $(nodeVersion)'
      inputs:
        versionSpec: '$(nodeVersion)'
        
    - script: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
      displayName: 'Install Python dependencies'
      
    - script: |
        cd frontend
        echo "Installing frontend dependencies..."
        npm ci
        
        echo "Building frontend application..."
        npm run build
        
        echo "Verifying build output..."
        if [ -f "../static/index.html" ] && [ -d "../static/assets" ]; then
          echo "Frontend build successful"
          echo "Contents of ../static/:"
          ls -la ../static/
          echo "Contents of ../static/assets/:"
          ls -la ../static/assets/
        else
          echo "Frontend build failed - no static directory or assets found"
          echo "Expected: ../static/index.html and ../static/assets/"
          echo "Checking what exists:"
          if [ -d "../static" ]; then
            echo "Static directory contents:"
            ls -la ../static/
          else
            echo "../static directory does not exist"
          fi
          exit 1
        fi
      displayName: 'Build Frontend'
      
    - script: |
        echo "Preparing deployment package..."
        mkdir -p $(Build.ArtifactStagingDirectory)/app
        
        # Copy application files
        cp -r *.py $(Build.ArtifactStagingDirectory)/app/ || true
        cp -r backend/ $(Build.ArtifactStagingDirectory)/app/ || true
        cp -r static/ $(Build.ArtifactStagingDirectory)/app/ || true
        cp requirements.txt $(Build.ArtifactStagingDirectory)/app/
        cp start.sh $(Build.ArtifactStagingDirectory)/app/
        cp gunicorn.conf.py $(Build.ArtifactStagingDirectory)/app/ || true
        cp WebApp.Dockerfile $(Build.ArtifactStagingDirectory)/app/ || true
        
        # Static directory (including built frontend) is already copied above
        echo "Frontend build files included in static/ directory"
        
        echo "Application package prepared"
        ls -la $(Build.ArtifactStagingDirectory)/app/
      displayName: 'Package Application'
      
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Application Artifact'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)/app'
        artifactName: 'copa-application'
        
  - job: PackageInfrastructure
    displayName: 'Package Infrastructure'
    pool:
      vmImage: $(vmImageName)
    steps:
    - checkout: self
      fetchDepth: 0
      
    - script: |
        echo "Preparing infrastructure package..."
        mkdir -p $(Build.ArtifactStagingDirectory)/infra
        
        # Copy Bicep templates
        cp -r infra/ $(Build.ArtifactStagingDirectory)/
        
        # Copy createUIDefinition for portal deployments (backup option)
        cp infrastructure/createUiDefinition.json $(Build.ArtifactStagingDirectory)/infra/ || true
        
        echo "Infrastructure package prepared"
        ls -la $(Build.ArtifactStagingDirectory)/infra/
      displayName: 'Package Infrastructure'
      
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Infrastructure Artifact'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)/infra'
        artifactName: 'copa-infrastructure'

- stage: DeployDevelopment
  displayName: 'Deploy to Development'
  dependsOn: []
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/Dev-Ops-Deployment'))
  variables:
  - group: 'copa-stop-search-dev-variables'
  - name: environmentName
    value: 'development'
  - name: resourceGroupName
    value: 'rg-btp-d-copa-stop-search'
  - name: azureLocation
    value: 'uksouth'
  - name: openAIModel
    value: 'gpt-35-turbo-16k'
  - name: embeddingModel
    value: 'text-embedding-ada-002'
  jobs:
  - deployment: DeployInfrastructure
    displayName: 'Deploy Infrastructure to Development'
    environment: 'BTP-Development'
    pool:
      vmImage: $(vmImageName)
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
            fetchDepth: 1
            condition: variables.infrastructureOnly
            
          - download: current
            artifact: 'copa-infrastructure'
            condition: not(variables.infrastructureOnly)
            
          - download: current
            artifact: 'copa-application'
            condition: not(variables.infrastructureOnly)
            
          - task: AzureCLI@2
            displayName: 'Create Resource Group'
            inputs:
              azureSubscription: $(azureServiceConnectionDev)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Creating resource group with required BTP policy tags..."
                az group create \
                  --name $(resourceGroupName) \
                  --location $(azureLocation) \
                  --tags \
                    Owner="DevOps-Pipeline" \
                    CostCentre="IT-001" \
                    ForceID="BTP" \
                    ServiceName="CoPA-Stop-Search" \
                    LocationID="UK-South" \
                    Environment="Development"
                echo "Resource group created successfully with all required tags"
                
          - task: AzurePowerShell@5
            displayName: 'Deploy Infrastructure with PowerShell (Avoiding CLI Bug)'
            inputs:
              azureSubscription: $(azureServiceConnectionDev)
              ScriptType: 'InlineScript'
              azurePowerShellVersion: 'LatestVersion'
              pwsh: true
              Inline: |
                $ErrorActionPreference = 'Stop'
                
                Write-Host "üöÄ Starting PowerShell-based infrastructure deployment (Bypassing Azure CLI 2.77.0 bug)"
                
                # Always use source files when artifacts aren't downloaded
                $artifactsPath = "$(Pipeline.Workspace)/copa-infrastructure/main.bicep"
                $sourcePath = "infra/main.bicep"
                
                if (Test-Path $artifactsPath) {
                  Write-Host "üì¶ Using pipeline artifacts (full deployment mode)"
                  $templatePath = $artifactsPath
                  $parametersPath = "$(Pipeline.Workspace)/copa-infrastructure/main.devops.parameters.json"
                } else {
                  Write-Host "üìÅ Using source files (infrastructure-only mode or no artifacts)"
                  $templatePath = $sourcePath
                  $parametersPath = "infra/main.devops.parameters.json"
                }
                
                Write-Host "üìÑ Template path: $templatePath"
                Write-Host "‚öôÔ∏è  Parameters path: $parametersPath"
                
                # Verify files exist
                if (-not (Test-Path $templatePath)) {
                  Write-Error "‚ùå Template file not found at: $templatePath"
                  Write-Host "üìÇ Current directory: $(Get-Location)"
                  if (Test-Path "infra/") {
                    Write-Host "üìã Available files in infra/:"
                    Get-ChildItem "infra/" | Format-Table Name, Length
                  }
                  throw "Template file not found"
                }
                
                if (-not (Test-Path $parametersPath)) {
                  Write-Error "‚ùå Parameters file not found at: $parametersPath"
                  throw "Parameters file not found"
                }
                
                Write-Host "‚úÖ Files verified successfully"
                
                # Load parameters from JSON file
                try {
                  $parametersJson = Get-Content -Path $parametersPath -Raw | ConvertFrom-Json
                  $parameters = @{}
                  
                  # Convert JSON parameters to hashtable format required by PowerShell
                  $parametersJson.parameters.PSObject.Properties | ForEach-Object {
                    $parameters[$_.Name] = $_.Value.value
                  }
                  
                  Write-Host "üìã Loaded parameters from file:"
                  $parameters.GetEnumerator() | Sort-Object Name | ForEach-Object {
                    if ($_.Name -like "*password*" -or $_.Name -like "*key*" -or $_.Name -like "*secret*") {
                      Write-Host "  $($_.Name) = ***MASKED***"
                    } else {
                      Write-Host "  $($_.Name) = $($_.Value)"
                    }
                  }
                  
                  # Add OpenAI model parameters if variables are set
                  if ("$(openAIModel)" -ne "`$(openAIModel)" -and "$(openAIModel)" -ne "") {
                    $parameters['openAIModelName'] = "$(openAIModel)"
                    Write-Host "ü§ñ Added OpenAI model: $(openAIModel)"
                  }
                  
                  if ("$(embeddingModel)" -ne "`$(embeddingModel)" -and "$(embeddingModel)" -ne "") {
                    $parameters['embeddingModelName'] = "$(embeddingModel)"
                    Write-Host "üìä Added embedding model: $(embeddingModel)"
                  }
                  
                } catch {
                  Write-Error "‚ùå Failed to load parameters: $($_.Exception.Message)"
                  throw
                }
                
                # Create deployment name
                $deploymentName = "$(Build.BuildNumber)-infrastructure-$((Get-Date).ToString('yyyyMMdd-HHmmss'))"
                Write-Host "üè∑Ô∏è  Deployment name: $deploymentName"
                
                try {
                  # First, validate the template before attempting deployment
                  Write-Host "üîç Validating Bicep template before deployment..."
                  Write-Host "üìç Target location: $(azureLocation)"
                  
                  $validationResult = Test-AzSubscriptionDeployment `
                    -Location "$(azureLocation)" `
                    -TemplateFile $templatePath `
                    -TemplateParameterObject $parameters `
                    -Verbose
                  
                  if ($validationResult) {
                    Write-Host "‚ùå Template validation failed with the following errors:"
                    foreach ($error in $validationResult) {
                      Write-Host "  üö´ Error Code: $($error.Code)"
                      Write-Host "  üìù Message: $($error.Message)"
                      if ($error.Details) {
                        Write-Host "  ÔøΩ Details: $($error.Details | ConvertTo-Json -Depth 3)"
                      }
                      if ($error.Target) {
                        Write-Host "  üéØ Target: $($error.Target)"
                      }
                    }
                    throw "Template validation failed. See errors above."
                  }
                  
                  Write-Host "‚úÖ Template validation passed successfully!"
                  
                  # Deploy infrastructure using PowerShell (avoids CLI response handling bug)
                  Write-Host "üöÄ Starting Bicep deployment with PowerShell..."
                  
                  $deploymentResult = New-AzSubscriptionDeployment `
                    -Name $deploymentName `
                    -Location "$(azureLocation)" `
                    -TemplateFile $templatePath `
                    -TemplateParameterObject $parameters `
                    -Verbose
                  
                  Write-Host "‚úÖ Infrastructure deployment completed successfully!"
                  Write-Host "üìä Final State: $($deploymentResult.ProvisioningState)"
                  Write-Host "üÜî Deployment ID: $($deploymentResult.Id)"
                  
                  # Output deployment results
                  if ($deploymentResult.Outputs) {
                    Write-Host "üì§ Deployment Outputs:"
                    $deploymentResult.Outputs | ConvertTo-Json -Depth 3
                    
                    # Extract web app name from outputs or use BTP naming convention
                    if ($deploymentResult.Outputs.ContainsKey('webAppName')) {
                      $webAppName = $deploymentResult.Outputs.webAppName.Value
                    } else {
                      $webAppName = "app-btp-d-copa-stop-search-001"
                    }
                  } else {
                    # Fallback to BTP naming convention
                    $webAppName = "app-btp-d-copa-stop-search-001"
                  }
                  
                  Write-Host "üåê Web App Name: $webAppName"
                  Write-Host "##vso[task.setvariable variable=webAppName]$webAppName"
                  
                } catch {
                  Write-Error "‚ùå PowerShell deployment failed: $($_.Exception.Message)"
                  Write-Host "üîç Exception details: $($_.Exception.ToString())"
                  
                  # Try to get deployment details for debugging
                  try {
                    Write-Host "üîç Attempting to get deployment status..."
                    $deployment = Get-AzSubscriptionDeployment -Name $deploymentName -ErrorAction SilentlyContinue
                    if ($deployment) {
                      Write-Host "üìä Deployment State: $($deployment.ProvisioningState)"
                      
                      if ($deployment.ProvisioningState -eq "Failed") {
                        Write-Host "üîç Getting deployment operation details..."
                        $operations = Get-AzSubscriptionDeploymentOperation -DeploymentName $deploymentName -ErrorAction SilentlyContinue
                        
                        if ($operations) {
                          foreach ($op in $operations | Where-Object { $_.Properties.ProvisioningState -eq "Failed" }) {
                            Write-Host "‚ùå Failed Operation:"
                            Write-Host "  Resource: $($op.Properties.TargetResource.ResourceName)"
                            Write-Host "  Type: $($op.Properties.TargetResource.ResourceType)"
                            if ($op.Properties.StatusMessage) {
                              Write-Host "  Error: $($op.Properties.StatusMessage | ConvertTo-Json -Depth 5)"
                            }
                          }
                        }
                      }
                    } else {
                      Write-Host "‚ö†Ô∏è  Could not retrieve deployment information"
                    }
                  } catch {
                    Write-Host "‚ö†Ô∏è  Error getting deployment details: $($_.Exception.Message)"
                  }
                  
                  throw
                }
                
          - task: AzureCLI@2
            displayName: 'Verify Web App Exists'
            condition: not(variables.infrastructureOnly)
            inputs:
              azureSubscription: $(azureServiceConnectionDev)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Checking if web app exists: $(webAppName)"
                
                if az webapp show --name "$(webAppName)" --resource-group "$(resourceGroupName)" >/dev/null 2>&1; then
                  echo "‚úÖ Web app $(webAppName) exists and is ready for deployment"
                else
                  echo "‚ùå Web app $(webAppName) does not exist!"
                  echo "Available web apps in resource group $(resourceGroupName):"
                  az webapp list --resource-group "$(resourceGroupName)" --query "[].name" --output table || echo "No web apps found"
                  exit 1
                fi
                    
          - task: AzureWebApp@1
            displayName: 'Deploy Application'
            condition: not(variables.infrastructureOnly)
            inputs:
              azureSubscription: $(azureServiceConnectionDev)
              appType: 'webAppLinux'
              appName: '$(webAppName)'
              package: '$(Pipeline.Workspace)/copa-application'
              runtimeStack: 'PYTHON|3.11'
              
          - task: AzureCLI@2
            displayName: 'Verify Application Deployment'
            condition: not(variables.infrastructureOnly)
            inputs:
              azureSubscription: $(azureServiceConnectionDev)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Verifying web app deployment..."
                WEB_APP_URL="https://$(webAppName).azurewebsites.net"
                echo "Web app URL: $WEB_APP_URL"
                
                # Wait a moment for the app to start
                sleep 30
                
                # Check if the app is responding
                HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$WEB_APP_URL" || echo "000")
                echo "HTTP Status: $HTTP_STATUS"
                
                if [[ "$HTTP_STATUS" == "200" ]] || [[ "$HTTP_STATUS" == "302" ]]; then
                  echo "‚úÖ Web app is responding successfully"
                else
                  echo "‚ö†Ô∏è Web app returned status $HTTP_STATUS, but deployment completed"
                  echo "This might be normal if the app takes time to start"
                fi

- stage: DeployProduction
  displayName: 'Deploy to Production'
  dependsOn: BuildAndPackage
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  variables:
  - group: 'copa-stop-search-prod-variables'
  - name: environmentName
    value: 'production'
  - name: resourceGroupName
    value: 'rg-btp-p-copa-stop-search'
  - name: azureLocation
    value: 'uksouth'
  - name: openAIModel
    value: 'gpt-35-turbo-16k'
  - name: embeddingModel
    value: 'text-embedding-ada-002'
  jobs:
  - deployment: DeployInfrastructure
    displayName: 'Deploy Infrastructure to Production'
    environment: 'BTP-Production'
    pool:
      vmImage: $(vmImageName)
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: none
            
          - download: current
            artifact: 'copa-infrastructure'
            
          - download: current
            artifact: 'copa-application'
            
          - task: AzureCLI@2
            displayName: 'Create Resource Group'
            inputs:
              azureSubscription: $(azureServiceConnectionProd)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Creating production resource group with required BTP policy tags..."
                az group create \
                  --name $(resourceGroupName) \
                  --location $(azureLocation) \
                  --tags \
                    Owner="Production-Team" \
                    CostCentre="IT-001" \
                    ForceID="BTP" \
                    ServiceName="CoPA-Stop-Search" \
                    LocationID="UK-South" \
                    Environment="Production"
                echo "Production resource group created successfully with all required tags"
            
          - task: AzurePowerShell@5
            displayName: 'Deploy Infrastructure with PowerShell (Production)'
            inputs:
              azureSubscription: $(azureServiceConnectionProd)
              ScriptType: 'InlineScript'
              azurePowerShellVersion: 'LatestVersion'
              pwsh: true
              Inline: |
                $ErrorActionPreference = 'Stop'
                
                Write-Host "üöÄ Starting PRODUCTION PowerShell-based infrastructure deployment"
                
                $templatePath = "$(Pipeline.Workspace)/copa-infrastructure/main.bicep"
                $parametersPath = "$(Pipeline.Workspace)/copa-infrastructure/main.production.parameters.json"
                
                Write-Host "üìÑ Production Template path: $templatePath"
                Write-Host "‚öôÔ∏è  Production Parameters path: $parametersPath"
                
                # Verify files exist
                if (-not (Test-Path $templatePath)) {
                  Write-Error "‚ùå Production template file not found at: $templatePath"
                  Write-Host "üìÇ Available files in artifact:"
                  Get-ChildItem "$(Pipeline.Workspace)/copa-infrastructure/" | Format-Table Name, Length
                  throw "Production template file not found"
                }
                
                if (-not (Test-Path $parametersPath)) {
                  Write-Error "‚ùå Production parameters file not found at: $parametersPath"
                  throw "Production parameters file not found"
                }
                
                Write-Host "‚úÖ Production files verified successfully"
                
                # Load parameters for production
                try {
                  $parametersJson = Get-Content -Path $parametersPath -Raw | ConvertFrom-Json
                  $parameters = @{}
                  
                  # Convert JSON parameters to hashtable
                  $parametersJson.parameters.PSObject.Properties | ForEach-Object {
                    $parameters[$_.Name] = $_.Value.value
                  }
                  
                  Write-Host "üìã Loaded PRODUCTION parameters:"
                  $parameters.GetEnumerator() | Sort-Object Name | ForEach-Object {
                    if ($_.Name -like "*password*" -or $_.Name -like "*key*" -or $_.Name -like "*secret*") {
                      Write-Host "  $($_.Name) = ***MASKED***"
                    } else {
                      Write-Host "  $($_.Name) = $($_.Value)"
                    }
                  }
                  
                  # Add OpenAI model parameters for production
                  if ("$(openAIModel)" -ne "`$(openAIModel)" -and "$(openAIModel)" -ne "") {
                    $parameters['openAIModelName'] = "$(openAIModel)"
                    Write-Host "ü§ñ Added PRODUCTION OpenAI model: $(openAIModel)"
                  }
                  
                  if ("$(embeddingModel)" -ne "`$(embeddingModel)" -and "$(embeddingModel)" -ne "") {
                    $parameters['embeddingModelName'] = "$(embeddingModel)"
                    Write-Host "üìä Added PRODUCTION embedding model: $(embeddingModel)"
                  }
                  
                } catch {
                  Write-Error "‚ùå Failed to load production parameters: $($_.Exception.Message)"
                  throw
                }
                
                # Create production deployment name
                $deploymentName = "$(Build.BuildNumber)-prod-infrastructure-$((Get-Date).ToString('yyyyMMdd-HHmmss'))"
                Write-Host "üè∑Ô∏è  PRODUCTION Deployment name: $deploymentName"
                
                try {
                  # First, validate the production template before attempting deployment
                  Write-Host "ÔøΩ Validating PRODUCTION Bicep template before deployment..."
                  Write-Host "üìç Target location: $(azureLocation)"
                  
                  $validationResult = Test-AzSubscriptionDeployment `
                    -Location "$(azureLocation)" `
                    -TemplateFile $templatePath `
                    -TemplateParameterObject $parameters `
                    -Verbose
                  
                  if ($validationResult) {
                    Write-Host "‚ùå PRODUCTION template validation failed with the following errors:"
                    foreach ($validationError in $validationResult) {
                      Write-Host "  üö´ Error Code: $($validationError.Code)"
                      Write-Host "  üìù Message: $($validationError.Message)"
                      if ($validationError.Details) {
                        Write-Host "  üîç Details: $($validationError.Details | ConvertTo-Json -Depth 3)"
                      }
                      if ($validationError.Target) {
                        Write-Host "  üéØ Target: $($validationError.Target)"
                      }
                    }
                    throw "PRODUCTION template validation failed. See errors above."
                  }
                  
                  Write-Host "‚úÖ PRODUCTION template validation passed successfully!"
                  
                  # Deploy production infrastructure using PowerShell
                  Write-Host "üöÄ Starting PRODUCTION Bicep deployment with PowerShell..."
                  
                  $deploymentResult = New-AzSubscriptionDeployment `
                    -Name $deploymentName `
                    -Location "$(azureLocation)" `
                    -TemplateFile $templatePath `
                    -TemplateParameterObject $parameters `
                    -Verbose
                  
                  Write-Host "‚úÖ PRODUCTION infrastructure deployment completed successfully!"
                  Write-Host "üìä Final State: $($deploymentResult.ProvisioningState)"
                  Write-Host "üÜî Deployment ID: $($deploymentResult.Id)"
                  
                  # Output deployment results for production
                  if ($deploymentResult.Outputs) {
                    Write-Host "üì§ PRODUCTION Deployment Outputs:"
                    $deploymentResult.Outputs | ConvertTo-Json -Depth 3
                    
                    # Extract web app name for production
                    if ($deploymentResult.Outputs.ContainsKey('webAppName')) {
                      $webAppName = $deploymentResult.Outputs.webAppName.Value
                    } else {
                      $webAppName = "app-btp-p-copa-stop-search-001"
                    }
                  } else {
                    # Fallback to production BTP naming convention
                    $webAppName = "app-btp-p-copa-stop-search-001"
                  }
                  
                  Write-Host "üåê PRODUCTION Web App Name: $webAppName"
                  Write-Host "##vso[task.setvariable variable=webAppName]$webAppName"
                  
                } catch {
                  Write-Error "‚ùå PRODUCTION PowerShell deployment failed: $($_.Exception.Message)"
                  Write-Host "üîç Exception details: $($_.Exception.ToString())"
                  
                  # Try to get production deployment details for debugging
                  try {
                    Write-Host "üîç Getting PRODUCTION deployment status..."
                    $deployment = Get-AzSubscriptionDeployment -Name $deploymentName -ErrorAction SilentlyContinue
                    if ($deployment) {
                      Write-Host "üìä PRODUCTION Deployment State: $($deployment.ProvisioningState)"
                      
                      if ($deployment.ProvisioningState -eq "Failed") {
                        Write-Host "üîç Getting PRODUCTION deployment operation details..."
                        $operations = Get-AzSubscriptionDeploymentOperation -DeploymentName $deploymentName -ErrorAction SilentlyContinue
                        
                        if ($operations) {
                          foreach ($op in $operations | Where-Object { $_.Properties.ProvisioningState -eq "Failed" }) {
                            Write-Host "‚ùå Failed PRODUCTION Operation:"
                            Write-Host "  Resource: $($op.Properties.TargetResource.ResourceName)"
                            Write-Host "  Type: $($op.Properties.TargetResource.ResourceType)"
                            if ($op.Properties.StatusMessage) {
                              Write-Host "  Error: $($op.Properties.StatusMessage | ConvertTo-Json -Depth 5)"
                            }
                          }
                        }
                      }
                    }
                  } catch {
                    Write-Host "‚ö†Ô∏è  Error getting PRODUCTION deployment details: $($_.Exception.Message)"
                  }
                  
                  throw
                }
                
          - task: AzureCLI@2
            displayName: 'Verify Web App Exists'
            inputs:
              azureSubscription: $(azureServiceConnectionProd)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Checking if production web app exists: $(webAppName)"
                
                if az webapp show --name "$(webAppName)" --resource-group "$(resourceGroupName)" >/dev/null 2>&1; then
                  echo "‚úÖ Production web app $(webAppName) exists and is ready for deployment"
                else
                  echo "‚ùå Production web app $(webAppName) does not exist!"
                  echo "Available web apps in resource group $(resourceGroupName):"
                  az webapp list --resource-group "$(resourceGroupName)" --query "[].name" --output table || echo "No web apps found"
                  exit 1
                fi
                    
          - task: AzureWebApp@1
            displayName: 'Deploy Application'
            inputs:
              azureSubscription: $(azureServiceConnectionProd)
              appType: 'webAppLinux'
              appName: '$(webAppName)'
              package: '$(Pipeline.Workspace)/copa-application'
              runtimeStack: 'PYTHON|3.11'
              
          - task: AzureCLI@2
            displayName: 'Verify Production Application Deployment'
            inputs:
              azureSubscription: $(azureServiceConnectionProd)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Verifying production web app deployment..."
                WEB_APP_URL="https://$(webAppName).azurewebsites.net"
                echo "Production web app URL: $WEB_APP_URL"
                
                # Wait a moment for the app to start
                sleep 30
                
                # Check if the app is responding
                HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$WEB_APP_URL" || echo "000")
                echo "HTTP Status: $HTTP_STATUS"
                
                if [[ "$HTTP_STATUS" == "200" ]] || [[ "$HTTP_STATUS" == "302" ]]; then
                  echo "‚úÖ Production web app is responding successfully"
                else
                  echo "‚ö†Ô∏è Production web app returned status $HTTP_STATUS, but deployment completed"
                  echo "This might be normal if the app takes time to start"
                fi